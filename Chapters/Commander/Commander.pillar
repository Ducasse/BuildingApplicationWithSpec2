!!Commander: a Powerful and Simple Command Framework

Commander is a library originally developed by Denis Kudriashov. Commander 2.0 is the second iteration of such library. Commander 2 has been designed by J. Delplanque and S. Ducasse. Note that Commander20 is not compatible with Commander but this is really easy to migrate from Commander to Commander 20. This document describes Commander 20 in the context of Spec20, the user interface building framework.

%+>figures/rmod.png|width=30+

!!! Commands

Commander models application actions as first class objects following the Command design pattern. Every action is implemented as a separate command class (subclass of ==CmCommand==) with an ==execute== method and all state required for execution.

With Commander you can express commands and use them to generate menus, toolbar but also to script an application from the command line.


Let's start with a sample application: a Contact book

!!! A contact book model

We start defining a little domain model for our example: we define a contact and a contact book

!!!! Contact
We start by defining a simple contact class.

[[[
Object subclass: #CmContact
	instanceVariableNames: 'name phone'
	classVariableNames: ''
	package: 'Commander2-ContactBook-Model'
]]]

We just define a printOn: method and a couple of accessors.
[[[
CmContact >> printOn: aStream
		super printOn: aStream.
	
		aStream nextPut: $(.
		aStream nextPutAll: name.
		aStream nextPut: $).
]]]


[[[
CmContact >> name
	^ name
]]]

[[[
CmContact >> phone
	^ phone
]]]

[[[
CmContact >> name: aString
	name := aString
]]]

[[[
CmContact >> phone: anObject
	phone := anObject
]]]

!!!! ContactBook
We start by defining a simple contact class.

[[[
Object subclass: #CmContactBook
	instanceVariableNames: 'contents'
	classVariableNames: ''
	package: 'Commander2-ContactBook-Model'
]]]

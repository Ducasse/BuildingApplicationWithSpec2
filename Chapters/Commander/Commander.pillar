!!Commander: a Powerful and Simple Command Framework

Commander is a library originally developed by Denis Kudriashov. Commander 2.0 is the second iteration of such library. Commander 2 has been designed by J. Delplanque and S. Ducasse. Note that Commander20 is not compatible with Commander but this is really easy to migrate from Commander to Commander 20. This document describes Commander 20 in the context of Spec20, the user interface building framework.

%+>figures/rmod.png|width=30+

!!! Commands

Commander models application actions as first class objects following the Command design pattern. Every action is implemented as a separate command class (subclass of ==CmCommand==) with an ==execute== method and all state required for execution.

With Commander you can express commands and use them to generate menus, toolbar but also to script an application from the command line.


Let's start with a sample application: a Contact book

!!! A contact book model

We start defining a little domain model for our example: we define a contact and a contact book

!!!! Contact
We start by defining a simple contact class.

[[[
Object subclass: #CmContact
	instanceVariableNames: 'name phone'
	classVariableNames: ''
	package: 'Commander2-ContactBook-Model'
]]]

We just define a printOn: method and a couple of accessors.
[[[
CmContact >> printOn: aStream
		super printOn: aStream.
	
		aStream nextPut: $(.
		aStream nextPutAll: name.
		aStream nextPut: $).
]]]


[[[
CmContact >> name
	^ name
]]]

[[[
CmContact >> phone
	^ phone
]]]

[[[
CmContact >> name: aString
	name := aString
]]]

[[[
CmContact >> phone: anObject
	phone := anObject
]]]

!!!! ContactBook
Now we define the contact book class. It is also straighforward. 

[[[
Object subclass: #CmContactBook
	instanceVariableNames: 'contents'
	classVariableNames: ''
	package: 'Commander2-ContactBook-Model'
]]]


[[[
CmContactBook >> initialize
		super initialize.
		contents := OrderedCollection new.
]]]

[[[
CmContactBook >> contents
	^ contents
]]]

[[[
CmContactBook >> contents: anObject
	contents := anObject
]]]



We add the possibility to add and remove a contact

[[[
CmContactBook >> addContact: aContact
	contents add: aContact
]]]


[[[
CmContactBook >> removeContact: aContact
	contents remove: aContact
]]]

[[[
CmContactBook >> addContact: newContact after: contactAfter 
	contents add: newContact after: contactAfter
]]]

We add a simple testing method in case you want to write some tests (which we urge you to do).

[[[
CmContactBook >> 	includesContact: aContact
	^ contents includes: aContact
]]]

And now we can add the most important method

[[[
CmContactBook >> add: contactName phone: phone
	| contact |
	contact := CmContact named: contactName phone: phone.
	self addContact: contact.
	^ contact
]]]



!!Commander: a Powerful and Simple Command Framework

Commander is a library originally developed by Denis Kudriashov. Commander 2.0 is the second iteration of such library. Commander 2 has been designed by J. Delplanque and S. Ducasse. Note that Commander20 is not compatible with Commander but this is really easy to migrate from Commander to Commander 20. This document describes Commander 20 in the context of Spec20, the user interface building framework.

%+>figures/rmod.png|width=30+

!!! Commands

Commander models application actions as first class objects following the Command design pattern. Every action is implemented as a separate command class (subclass of ==CmCommand==) with an ==execute== method and all state required for execution.

With Commander you can express commands and use them to generate menus, toolbar but also to script an application from the command line.


Let's start with a sample application: a Contact book

!!! A contact book model

We start defining a little domain model for our example: we define a contact and a contact book

!!!! Contact
We start by defining a simple contact class.

[[[
Object subclass: #CmContact
	instanceVariableNames: 'name phone'
	classVariableNames: ''
	package: 'Commander2-ContactBook-Model'
]]]

We just define a printOn: method and a couple of accessors.
[[[
CmContact >> printOn: aStream
		super printOn: aStream.
	
		aStream nextPut: $(.
		aStream nextPutAll: name.
		aStream nextPut: $).
]]]


[[[
CmContact >> name
	^ name
]]]

[[[
CmContact >> phone
	^ phone
]]]

[[[
CmContact >> name: aString
	name := aString
]]]

[[[
CmContact >> phone: anObject
	phone := anObject
]]]

!!!! ContactBook
Now we define the contact book class. It is also straighforward. 

[[[
Object subclass: #CmContactBook
	instanceVariableNames: 'contents'
	classVariableNames: ''
	package: 'Commander2-ContactBook-Model'
]]]


[[[
CmContactBook >> initialize
		super initialize.
		contents := OrderedCollection new.
]]]

[[[
CmContactBook >> contents
	^ contents
]]]

[[[
CmContactBook >> contents: anObject
	contents := anObject
]]]



We add the possibility to add and remove a contact

[[[
CmContactBook >> addContact: aContact
	contents add: aContact
]]]


[[[
CmContactBook >> removeContact: aContact
	contents remove: aContact
]]]

[[[
CmContactBook >> addContact: newContact after: contactAfter 
	contents add: newContact after: contactAfter
]]]

We add a simple testing method in case you want to write some tests (which we urge you to do).

[[[
CmContactBook >> 	includesContact: aContact
	^ contents includes: aContact
]]]

And now we can add the most important method

[[[
CmContactBook >> add: contactName phone: phone
	| contact |
	contact := CmContact named: contactName phone: phone.
	self addContact: contact.
	^ contact
]]]

!!! Prefilling up the contact book

Since we want to have some contacts and we way to keep them without resorting 
to a database or file we set some class instance variables. 

We defined two class instance variables: ==family== and ==coworkers== and define
some class method accessors as follows: 

[[[
CmContactBook class >> family
	^family ifNil: [ 
		family := self new 
			add: 'John' phone: '342 345';
			add: 'Bill' phone: '123 678';
			add: 'Marry' phone: '789 567';
			yourself]
]]]

[[[
CmContactBook class >> coworkers
	^coworkers ifNil: [ 
		coworkers := self new 
			add: 'Stef' phone: '112 378';
			add: 'Pavel' phone: '898 678';
			add: 'Marcus' phone: '444 888';
			yourself]
]]]

We add one method to be able to reset them if necessary.

[[[
CmContactBook class >> reset
	<script>
	coworkers := nil.
	family := nil
]]]


!!! A Simple UI

Now we define the application we want to get to illustrate Commander. The application UI is shown in Figure *@final*.

+A rudimentary contact book application.>figures/final.png|width=60|label=final+

We define the class ==CmContactBookPresenter==. It holds a reference to a contact book 
and it is structured around a table. 

[[[
ComposablePresenter subclass: #CmContactBookPresenter
	instanceVariableNames: 'table contactBook'
	classVariableNames: ''
	package: 'Commander2-ContactBook-Spec'
]]]

We define an accessor for the contact book and the table.

[[[
CmContactBookPresenter >> contactBook
	^ contactBook
]]]

[[[
CmContactBookPresenter >> table: anObject
	table := anObject
]]]

[[[
CmContactBookPresenter >> table
	^ table
]]]

!!! Initializing the model

We specialize the method ==setModelBeforeInitialization:== that is invoked by the framework to assign the contactBook instance variable to the object passed during the 
execution of the expression ==(CmContactBookPresenter on: CmContactBook coworkers) openWithSpec==.

[[[
CmContactBookPresenter >> setModelBeforeInitialization: aContactBook
	super setModelBeforeInitialization: aContactBook.
	contactBook := aContactBook
]]]


!!!! Layout

[[[
CmContactBookPresenter class >> defaultSpec

	^ SpecLayout composed
		newColumn: [ :column |
			column add: #table];
		yourself
]]]

!!!! Widget initialization

We initialize the table to display two columns for the name and the phone. 
The respective accessors willbe sent to the elements to fill up the columns.
Finally the table contents is set using the contact book contents.
[[[
CmContactBookPresenter class >> initializeWidgets
	table := self newTable.
	table 
		addColumn: (StringTableColumn title: 'Name' evaluated: #name);
		addColumn: (StringTableColumn title: 'Phone' evaluated: #phone).
	table items: contactBook contents.
]]]

Now we can start opening the UI by executing the following snippet
==(CmContactBookPresenter on: CmContactBook coworkers) openWithSpec==

We define a class method to be able to easily reexecute the set up. 
[[[
CmContactBookPresenter class >> coworkersExample
	<example>
	^ (self on: CmContactBook coworkers) openWithSpec 
]]]

You should obtain the following UI as shown in Figure *@first*.

+First version without menus and toolbar.>figures/firstVersion.png|width=60|label=first+


[[[
CmContactBookPresenter >> newContact
	| rawData splitted |
	rawData := self 
		request: 'Enter new contact name and phone (split by comma)' 
		initialAnswer: '' 
		title: 'Create new contact'.
	splitted := rawData splitOn: $,.
	(splitted size = 2 and: [ splitted allSatisfy: #isNotEmpty ])
		ifFalse: [ InvalidUserInput signal: 'Please enter contact name and phone (split by comma)'  ].

	^ CmContact new
		name: splitted first;
		phone: splitted second;
		yourself
]]]

To test it, we can get access to the presenter as follows 
[[[
(CmContactBookPresenter2 on: CmContactBook coworkers) 
	openWithSpec presenter inspect
]]]

and you can send the ==newContact== message as shown in Figure *@inspector*.

+Playing inside the inspector.>figures/inspector.png|width=60|label=inspector+


!!! Defining Commands
A command is a simple object instance of a subclass of the class ==CmCommand==.
It has a description, a name (this name can be either static or dynamic as we will later on). In addition it has a context from which it extracts information to execute itself. But let us have a look at examples. 

For convenience reasons, we define a common superclass named ==CmContactBookCommand== to all the commands  of the contact book application.

[[[
CmCommand subclass: #CmContactBookCommand
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Commander2-ContactBook-Commands'
]]]



We define a simple helper method to make the code more readable
[[[
CmContactBookCommand >> contactBookPresenter
	^ self context
]]]

For the same reason, we define another helper to access the contact book.
[[[
CmContactBookCommand >> contactBook
	^ self contactBookPresenter contactBook
]]]

[[[
CmContactBookCommand >> selectedContact
	^ self contactBookPresenter selectedContact
]]]

Using such helper methods we defined the method ==hasSelectContract== as follows:

[[[
CmContactBookCommand >> hasSelectedContact
	^ self contactBookPresenter isContactSelected
]]]

!!!! Adding a contact

We define a subclass to define the add a contact command. 
[[[
CmContactBookCommand subclass: #CmAddContactCommand
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Commander2-ContactBook-Commands'
]]]

[[[
CmAddContactCommand >> initialize
	super initialize.
	self
		basicName: 'New contact'; 
		basicDescription: 'Creates a new contact and add it to the contact book.'
]]]

[[[
CmAddContactCommand >> execute
	"One should never manipulate UI directly from a commande.
	 Instead, you can use one of the subclass of LtCommandNotification.
	 The UI interactions will be handled by the command decorator.
	 Using this mechanism a command is not dependent on the context in which it is used.
	"
	| contact |
	contact := self context newContact.
	self hasSelectedContact
		ifTrue: [ self contactBook addContact: contact after: self selectedContact ]
		ifFalse: [ self contactBook addContact: contact ].
		
	self contactBookPresenter updateView
]]]

We should define the method updateView 

[[[
CmContactBookPresenter >> updateView
	table items: contactBook contents
]]]



!!! Turning commands into menu items

[[[
buildCommandsGroupWith: presenterInstance forRoot:

]]]

!!! Extending menus


!!! Toolbar
!!Commander: a Powerful and Simple Command Framework

Commander is a library originally developed by Denis Kudriashov. Commander 2.0 is the second iteration of such library. Commander 2 has been designed by J. Delplanque and S. Ducasse. Note that Commander20 is not compatible with Commander but this is really easy to migrate from Commander to Commander 20. This document describes Commander 20 in the context of Spec20, the user interface building framework.

%+>figures/rmod.png|width=30+

!!! Commands

Commander models application actions as first class objects following the Command design pattern. Every action is implemented as a separate command class (subclass of ==CmCommand==) with an ==execute== method and all state required for execution.

With Commander you can express commands and use them to generate menus, toolbar but also to script an application from the command line.


Let's start with a sample application: a Contact book

!!! A contact book model

We start defining a little domain model for our example: we define a contact and a contact book

!!!! Contact
We start by defining a simple contact class.

[[[
Object subclass: #CmContact
	instanceVariableNames: 'name phone'
	classVariableNames: ''
	package: 'Commander2-ContactBook-Model'
]]]

We just define a printOn: method and a couple of accessors.
[[[
CmContact >> printOn: aStream
		super printOn: aStream.
	
		aStream nextPut: $(.
		aStream nextPutAll: name.
		aStream nextPut: $).
]]]


[[[
CmContact >> name
	^ name
]]]

[[[
CmContact >> phone
	^ phone
]]]

[[[
CmContact >> name: aString
	name := aString
]]]

[[[
CmContact >> phone: anObject
	phone := anObject
]]]

!!!! ContactBook
Now we define the contact book class. It is also straighforward. 

[[[
Object subclass: #CmContactBook
	instanceVariableNames: 'contents'
	classVariableNames: ''
	package: 'Commander2-ContactBook-Model'
]]]


[[[
CmContactBook >> initialize
		super initialize.
		contents := OrderedCollection new.
]]]

[[[
CmContactBook >> contents
	^ contents
]]]

[[[
CmContactBook >> contents: anObject
	contents := anObject
]]]



We add the possibility to add and remove a contact

[[[
CmContactBook >> addContact: aContact
	contents add: aContact
]]]


[[[
CmContactBook >> removeContact: aContact
	contents remove: aContact
]]]

[[[
CmContactBook >> addContact: newContact after: contactAfter 
	contents add: newContact after: contactAfter
]]]

We add a simple testing method in case you want to write some tests (which we urge you to do).

[[[
CmContactBook >> 	includesContact: aContact
	^ contents includes: aContact
]]]

And now we can add the most important method

[[[
CmContactBook >> add: contactName phone: phone
	| contact |
	contact := CmContact named: contactName phone: phone.
	self addContact: contact.
	^ contact
]]]

!!! Prefilling up the contact book

Since we want to have some contacts and we way to keep them without resorting 
to a database or file we set some class instance variables. 

We defined two class instance variables: ==family== and ==coworkers== and define
some class method accessors as follows: 

[[[
CmContactBook class >> family
	^family ifNil: [ 
		family := self new 
			add: 'John' phone: '342 345';
			add: 'Bill' phone: '123 678';
			add: 'Marry' phone: '789 567';
			yourself]
]]]

[[[
CmContactBook class >> coworkers
	^coworkers ifNil: [ 
		coworkers := self new 
			add: 'Stef' phone: '112 378';
			add: 'Pavel' phone: '898 678';
			add: 'Marcus' phone: '444 888';
			yourself]
]]]

We add one method to be able to reset them if necessary.

[[[
CmContactBook class >> reset
	<script>
	coworkers := nil.
	family := nil
]]]


!!! A Simple UI

Now we define the application we want to get to illustrate Commander. The application UI is shown in Figure *@final*.

+A rudimentary contact book application.>figures/final.png|width=60|label=final+

We define the class ==CmContactBookPresenter==. It holds a reference to a contact book 
and it is structured around a table. 

[[[
ComposablePresenter subclass: #CmContactBookPresenter
	instanceVariableNames: 'table contactBook'
	classVariableNames: ''
	package: 'Commander2-ContactBook-Spec'
]]]

We define an accessor for the contact book and the table.

[[[
CmContactBookPresenter >> contactBook
	^ contactBook
]]]

[[[
CmContactBookPresenter >> table: anObject
	table := anObject
]]]

[[[
CmContactBookPresenter >> table
	^ table
]]]

!!! Initializing the model

We specialize the method ==setModelBeforeInitialization:== that is invoked by the framework to assign the contactBook instance variable to the object passed during the 
execution of the expression ==(CmContactBookPresenter on: CmContactBook coworkers) openWithSpec==.

[[[
CmContactBookPresenter >> setModelBeforeInitialization: aContactBook
	super setModelBeforeInitialization: aContactBook.
	contactBook := aContactBook
]]]


!!!! Layout

[[[
CmContactBookPresenter class >> defaultSpec

	^ SpecLayout composed
		newColumn: [ :column |
			column add: #table];
		yourself
]]]

!!!! Widget initialization

[[[
CmContactBookPresenter class >> initializeWidgets
	table := self newTable.
	table 
		addColumn: (StringTableColumn title: 'Name' evaluated: #name);
		addColumn: (StringTableColumn title: 'Phone' evaluated: #phone).
	table items: contactBook contents.
]]]

Now we can start opening the UI by executing the following snippet
==(CmContactBookPresenter on: CmContactBook coworkers) openWithSpec==

We define a class method to be able to easily reexecute the set up. 
[[[
CmContactBookPresenter class >> 	coworkersExample
	<example>
	^ (self on: CmContactBook coworkers) openWithSpec 
]]]

